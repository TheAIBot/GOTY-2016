package Game.View;

import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.Polygon;
import java.awt.geom.Point2D;
import java.awt.image.BufferedImage;
import javax.swing.JPanel;

import Game.Control.GameEngine.GraphicsManager;
import Game.View.ViewTypes.Colorfull;
import Game.View.ViewTypes.Displayable;
import Game.View.ViewTypes.Numreable;

public class GraphicsPanel extends JPanel {
	private static final long serialVersionUID = 1L; //autogenerated
	private static final int DEFAULT_TILE_SIZE = 100; //the size of a tile in pixels
	final int MIN_FONT_SIZE = 4;
	private final RenderInfo renderInfo;
	private final GraphicsManager gManager;
	private final int screenIndex;
	private boolean firstPaint = true; //used when rendering for the first time

	public GraphicsPanel(GraphicsManager gManager, RenderInfo renderInfo, int screenIndex) {
		super();
		this.gManager = gManager;
		this.setBackground(Color.WHITE);
		this.screenIndex = screenIndex;
		this.renderInfo = renderInfo;
		setFont(new Font("Verdana", 0, 12));
	}

	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		if (firstPaint) {
			setImageScale();
		}
		renderDisplayables(gManager.getDisplayablesToRender(screenIndex), g);
		renderColorfull(gManager.getColorfullsToRender(screenIndex), g);
		renderNumreable(gManager.getNumreablesToRender(screenIndex), g);
	}
	
	private void setImageScale()
	{
		double widthAndHeight = renderInfo.imageScale * DEFAULT_TILE_SIZE * renderInfo.getSize();
		double scaler = widthAndHeight / getHeight();
		double newImageScale = renderInfo.imageScale / scaler;
		renderInfo.setImageScale(newImageScale);
		firstPaint = false;
	}
	
	/**
	 * Render the tile images
	 * @param displayables
	 * @param gDisplay
	 */
	private void renderDisplayables(Displayable[] displayables, Graphics gDisplay){
		if (displayables != null) {
			for (Displayable d : displayables) {
				//Checks if the displayable has the neccesary information required for displaying it on the screen.
				if (d == null) {
					continue;
				}
				BufferedImage currentImage = d.getDisplayImage();
				Point2D.Double imagePosition = d.getDisplayPosition();
				if (AnyCornerInsideDisplay(d.getCorners(), d.getDisplayPosition(), DEFAULT_TILE_SIZE, DEFAULT_TILE_SIZE)) {
					
					//Move and scale the displayable to the corresponding position on the screen
					int destStartX = (int)Math.ceil((imagePosition.x + renderInfo.xOffset) * DEFAULT_TILE_SIZE * renderInfo.imageScale);
					int destStartY = (int)Math.ceil((imagePosition.y + renderInfo.yOffset) * DEFAULT_TILE_SIZE * renderInfo.imageScale);
					int destEndX = destStartX + (int)Math.ceil(DEFAULT_TILE_SIZE * renderInfo.imageScale);
					int destEndY = destStartY + (int)Math.ceil(DEFAULT_TILE_SIZE * renderInfo.imageScale);
					
					int srcStartX = (int)Math.ceil((getPosition(d.getNumber() - 1, renderInfo.getSize()).x) * (currentImage.getWidth() / renderInfo.getSize()));
					int srcStartY = (int)Math.ceil((getPosition(d.getNumber() - 1, renderInfo.getSize()).y ) * (currentImage.getHeight() / renderInfo.getSize()));
					int srcEndX = srcStartX + (int)Math.ceil(currentImage.getWidth() / renderInfo.getSize());
					int srcEndY = srcStartY + (int) Math.ceil(currentImage.getHeight() / renderInfo.getSize());
					
					gDisplay.drawImage(currentImage, 
									   destStartX, 
									   destStartY,
									   destEndX, 
									   destEndY,
									   srcStartX, 
									   srcStartY,
									   srcEndX, 
									   srcEndY,
									   null);
								
				}
			}
		}
	}
	
	/**
	 * Renders tile numbers in the middle of the relavent tile 
	 * @param numreables
	 * @param gDisplay
	 */
	private void renderNumreable(Numreable[] numreables, Graphics gDisplay){
		if (numreables != null && renderInfo.renderColor) {
			gDisplay.setColor(Color.WHITE);
			if (setFontSize(gDisplay) >= MIN_FONT_SIZE) {
				final Point2D.Double zero = new Point2D.Double(0, 0);
				for (Numreable numreable : numreables) {
					if (numreable != null) {
						Point2D.Double point = numreable.getNumberPosition();
						if (isInsideDisplay(point.x, point.y, zero, 
								DEFAULT_TILE_SIZE, DEFAULT_TILE_SIZE)) {
							final int x = (int) Math.ceil(((point.x + renderInfo.xOffset) * DEFAULT_TILE_SIZE + (DEFAULT_TILE_SIZE / 2)) * renderInfo.imageScale);
							final int y = (int) Math.ceil(((point.y + renderInfo.yOffset) * DEFAULT_TILE_SIZE + (DEFAULT_TILE_SIZE / 2)) * renderInfo.imageScale);
							//Finally draw the string contained in the numreable from the center of the tile
							final String toDraw = String.valueOf(numreable.getNumber());
							gDisplay.drawString(toDraw, x, y);
						}
					}
				}
			}
		}		
	}
	
	private int setFontSize(Graphics gDisplay)
	{
		int fontSize = (int) (20 * renderInfo.imageScale);
		if (gDisplay.getFont().getSize() != fontSize) {
			gDisplay.setFont(gDisplay.getFont().deriveFont(0, fontSize));
		}
		return fontSize;
	}
	
	/**
	 * Renders the colored tiles
	 * @param colored
	 * @param gDisplay
	 */
	private void renderColorfull(Colorfull[] colored, Graphics gDisplay){
		if (colored != null) {
			int[] xPoints = null;
			int[] yPoints = null;
			for (Colorfull colorfull : colored) {
				if (colorfull != null && 
					AnyCornerInsideDisplay(colorfull.getCorners(),colorfull.getColorPosition(), DEFAULT_TILE_SIZE, DEFAULT_TILE_SIZE)) {	
					
					Point[] corners = colorfull.getCorners();
					
					//create arrays only once
					if (xPoints == null) {
						xPoints = new int[corners.length];
						yPoints = new int[corners.length];
					}
					
					gDisplay.setColor(colorfull.getColor());
					for (int i = 0; i < corners.length; i++) { 
						xPoints[i] = (int) Math.ceil((corners[i].x + colorfull.getColorPosition().x + renderInfo.xOffset) * DEFAULT_TILE_SIZE * renderInfo.imageScale);
						yPoints[i] = (int) Math.ceil((corners[i].y + colorfull.getColorPosition().y + renderInfo.yOffset) * DEFAULT_TILE_SIZE * renderInfo.imageScale);						
					}
					gDisplay.fillPolygon(xPoints, yPoints, corners.length);
				}
			}
		}		
	}
		
	public boolean AnyCornerInsideDisplay(Point[] corners, Point2D.Double startingPosition, double scallingX, double scallingY){
		if (corners != null) {
			for (Point corner : corners) { 
				//Check after scaling and offset positioning, if the final position is contained in the window.
				if (isInsideDisplay(corner.x, corner.y, startingPosition, scallingX, scallingY)) {
					return true;
				}
			}
		}
		return false;
	}
	
	public boolean isInsideDisplay(double cornerX, double cornerY, Point2D.Double startingPosition, double scallingX, double scallingY){
		double x = (cornerX + startingPosition.x + renderInfo.xOffset) * scallingX * renderInfo.imageScale;
		double y = (cornerY + startingPosition.y + renderInfo.yOffset) * scallingY * renderInfo.imageScale;
		return (x < getWidth() &&
				y < getHeight() &&
				x >= 0 &&
				y >= 0);
	}
	
	public void render()
	{
		repaint();
	}
	
	/**
	 * 
	 * @param number
	 * @param size
	 * @return the corresponding position in the grid
	 */
	public Point getPosition(int number, int size) {
		int row = number / size;
		int col = number % size;
		return new Point(col, row);
	}
}
