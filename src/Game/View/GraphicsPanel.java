package Game.View;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Rectangle;
import java.awt.geom.Point2D;
import java.awt.image.BufferedImage;
import javax.swing.JPanel;

import Game.Control.GameEngine.GraphicsManager;

public class GraphicsPanel extends JPanel {
	private static final long serialVersionUID = 1L; //autogenerated
	private Displayable[] tiles;
	private final int tileSize = 100;
	private RenderInfo renderInfo;
	private final GraphicsManager gManager;


	public GraphicsPanel(GraphicsManager gManager) {
		super();
		this.gManager = gManager;
		this.setBackground(Color.WHITE);
	}

	public void setRenderInfo(Displayable[] tiles, RenderInfo renderInfo) {
		this.tiles = tiles;
		this.renderInfo = renderInfo;
	}

	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);		
		renderDisplayables(gManager.getDisplayablesToRender(), g);
		renderColorfull(gManager.getColorfullsToRender(), g);
		renderNumreable(gManager.getNumreablesToRender(), g);
	}
	
	private void renderDisplayables(Displayable[] displayables, Graphics gDisplay){
		if (displayables != null) {
			for (Displayable d : displayables) {
				//Checks if the displayable has the neccesary information required for displaying it on the screen.
				if (d == null) {
					continue;
				}
				BufferedImage currentImage = d.getDisplayImage();
				Point2D.Double imagePosition = d.getDisplayPosition();
				if (currentImage == null || imagePosition == null) {
					throw new NullPointerException();
				} else {
					//Checks if the displayable is in a position, so that the image can be displayed on the screen. 
					//If not, it dosen't render it (to increase performance), else it does.
					if (isInsideDisplay(d.getCorners(), d.getDisplayPosition(), currentImage.getWidth(), currentImage.getHeight())) {
						
						Rectangle destRect = new Rectangle((int) ((imagePosition.x + renderInfo.xOffset) * tileSize * renderInfo.imageScale), 
		  						   (int) ((imagePosition.y + renderInfo.yOffset) * tileSize * renderInfo.imageScale), (int) (tileSize * renderInfo.imageScale), 
		  						   (int) (tileSize * renderInfo.imageScale));						
						Rectangle srcRect = new Rectangle((int) ((getPosition(d.getNumber() - 1, renderInfo.getSize()).x) * (currentImage.getWidth() / renderInfo.getSize())), 
		  						  (int) ((getPosition(d.getNumber() - 1, renderInfo.getSize()).y ) * (currentImage.getHeight() / renderInfo.getSize())), 
		  						  (int) (currentImage.getWidth() / renderInfo.getSize()),
		  						  (int) (currentImage.getHeight() / renderInfo.getSize()));
						gDisplay.drawImage(currentImage, 
									   destRect.x, destRect.y,
									   destRect.x + destRect.width, destRect.y + destRect.height,
									   srcRect.x, srcRect.y,
									   srcRect.x + srcRect.width, srcRect.y + srcRect.height,
									   null);
									
					}
				}
			}
		}
	}
	
	private void renderNumreable(Numreable[] numreables, Graphics gDisplay){
		if (numreables != null) {
			for (Numreable numreable : numreables) {
				if (numreable != null) {
					Point2D.Double[] point = new Point2D.Double[]{numreable.getNumberPosition()};
					if (isInsideDisplay(point, new Point2D.Double(0, 0), 
							numreable.getNumberDisplayScallingX(), numreable.getNumberDisplayScallingY())) {
						gDisplay.setColor(Color.WHITE);
						gDisplay.drawString(String.valueOf(numreable.getNumber()), 
								(int) (((numreable.getNumberPosition().x + renderInfo.xOffset) * numreable.getNumberDisplayScallingX() + numreable.getNumberDisplayScallingX() / 2) * renderInfo.imageScale),
								(int) (((numreable.getNumberPosition().y + renderInfo.yOffset) * numreable.getNumberDisplayScallingY() + numreable.getNumberDisplayScallingY() / 2) * renderInfo.imageScale));
					}
				}
			}
		}		
	}
	
	private void renderColorfull(Colorfull[] colored, Graphics gDisplay){
		if (colored != null) {
			for (Colorfull colorfull : colored) {
				if (colorfull != null && isInsideDisplay(colorfull.getColorCorners(),colorfull.getColorPosition(), 1, 1)) {	
					gDisplay.setColor(colorfull.getColor());
					for (int i = 0; i < colorfull.getColorPolygon().npoints; i++) { //Kan værer en fejl her, med skiftet frem og tilbage imellem int og double (*)
						colorfull.getColorPolygon().xpoints[i] = (int) Math.round((colorfull.getColorPolygon().xpoints[i] + colorfull.getColorPosition().x + renderInfo.xOffset)*colorfull.getColorPolygonScallingX());
						colorfull.getColorPolygon().ypoints[i] = (int) Math.round((colorfull.getColorPolygon().ypoints[i] + colorfull.getColorPosition().y + renderInfo.yOffset)*colorfull.getColorPolygonScallingY());						
					}
					gDisplay.fillPolygon(colorfull.getColorPolygon());
					for (int i = 0; i < colorfull.getColorPolygon().npoints; i++) {
						colorfull.getColorPolygon().xpoints[i] = (int) Math.round((colorfull.getColorPolygon().xpoints[i] - colorfull.getColorPolygonScallingX() * (colorfull.getColorPosition().x + renderInfo.xOffset)) / colorfull.getColorPolygonScallingX());
						colorfull.getColorPolygon().ypoints[i] = (int) Math.round((colorfull.getColorPolygon().ypoints[i] - colorfull.getColorPolygonScallingY() * (colorfull.getColorPosition().y + renderInfo.yOffset)) / colorfull.getColorPolygonScallingY());
					}
				}
			}
		}		
	}
	
	public void render(){
		this.repaint();
	}
	
	
	public boolean isInsideDisplay(Point2D.Double[] corners, Point2D.Double startingPosition, double scallingX, double scallingY){
		if (corners != null) {
			for (Point2D.Double corner : corners) { //Mulighed for fejl ved store eller drejede billeder(*)
				if (corner != null && //Eventuelt ænder tileSize(*)
					(corner.x + startingPosition.x + renderInfo.xOffset) * scallingX * renderInfo.imageScale < getWidth() &&
					(corner.y + startingPosition.y + renderInfo.yOffset) * scallingY * renderInfo.imageScale < getHeight() &&
					(corner.x + startingPosition.x + renderInfo.xOffset) * scallingX * renderInfo.imageScale >= 0 &&
					(corner.y + startingPosition.y + renderInfo.yOffset) * scallingY * renderInfo.imageScale >= 0) {
					return true;
				}
			}
		}
		return false;		
	}
	
	
	public Point2D.Double getPosition(int number, int size) {
		int row = number / size;
		int col = number % size;
		return new Point2D.Double(col, row);
	}
}
