package Game.View;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
<<<<<<< HEAD
<<<<<<< HEAD
import java.awt.geom.Point2D;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
=======
import java.awt.Polygon;
import java.awt.image.BufferedImage;
import java.lang.reflect.Array;
import java.util.Arrays;
>>>>>>> refs/remotes/origin/Jesper

import javax.swing.JPanel;

import Game.Control.GameEngine.GraphicsManager;
<<<<<<< HEAD
=======
import Game.Model.Board.RenderInfo;
>>>>>>> refs/remotes/origin/Jesper

=======
import java.awt.Rectangle;
import java.awt.geom.Point2D;
import java.awt.image.BufferedImage;

import javax.swing.JPanel;

>>>>>>> refs/remotes/origin/Andreas-2-
public class GraphicsPanel extends JPanel {
	private static final long serialVersionUID = 1L; //autogenerated
	private Displayable[] tiles;
	private RenderInfo renderInfo;
<<<<<<< HEAD
<<<<<<< HEAD
=======
	private double imageScaling = 1;
	private final int tileSize = 100;
>>>>>>> refs/remotes/origin/Andreas-2-

	public GraphicsPanel() {
=======
	private double imageScaling = 1;
	private final GraphicsManager gManager;
	
	public GraphicsPanel(GraphicsManager gManager) {
>>>>>>> refs/remotes/origin/Jesper
		super();
		this.gManager = gManager;
		this.setBackground(Color.WHITE);
	}

	public void setRenderInfo(Displayable[] tiles, RenderInfo renderInfo) {
		this.tiles = tiles;
		this.renderInfo = renderInfo;
	}

	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);		
		renderDisplayables(gManager.getDisplayablesToRender(), g);
		renderColorfull(gManager.getColorfullsToRender(), g);
		renderNumreable(gManager.getNumreablesToRender(), g);
		
		/*
		if (tiles != null && renderInfo != null) {
			int painted = 0;
			for (Displayable tile : tiles) {
				if (tile != null) {
					if (render((Graphics2D) g, tile, renderInfo)) {
						painted++;
					}
				}
			}
			System.out.println(painted);
		}
		*/
	}
<<<<<<< HEAD

=======
	
	private void renderDisplayables(Displayable[] displayables, Graphics gDisplay){
		if (displayables != null) {
			for (Displayable d : displayables) {
				//Checks if the displayable has the neccesary information required for displaying it on the screen.
				if (d == null) {
					continue;
				}
				BufferedImage currentImage = d.getDisplayImage();
				Point imagePosition = d.getDisplayPosition();
				if (currentImage == null || imagePosition == null) {
					throw new NullPointerException();
				} else {
					//Checks if the displayable is in a position, so that the image can be displayed on the screen. 
					//If not, it dosen't render it (to increase performance), else it does.
					if (isInsideDisplay(d.getCorners(), d.getDisplayPosition(), currentImage.getWidth(), currentImage.getHeight())) {
						gDisplay.drawImage(currentImage, (int) (imagePosition.x * imageScaling * currentImage.getWidth()),
															 (int) (imagePosition.y * imageScaling * currentImage.getHeight()), null);
						
					}
				}
			}
		}
	}
	
	private void renderNumreable(Numreable[] numreables, Graphics gDisplay){
		if (numreables != null) {
			for (Numreable numreable : numreables) {
				if (numreable != null) {
					Point[] point = new Point[]{numreable.getNumberPosition()};
					if (isInsideDisplay(point, new Point(0, 0), 
							numreable.getNumberDisplayScallingX(), numreable.getNumberDisplayScallingY())) {
						gDisplay.setColor(Color.WHITE);
						gDisplay.drawString(String.valueOf(numreable.getNumber()), 
								(int) (numreable.getNumberPosition().x * imageScaling * numreable.getNumberDisplayScallingX() + numreable.getNumberDisplayScallingX() / 2),
								(int) (numreable.getNumberPosition().y * imageScaling * numreable.getNumberDisplayScallingY()  + numreable.getNumberDisplayScallingY()  / 2));
					}
				}
			}
		}		
	}
	
	private void renderColorfull(Colorfull[] colored, Graphics gDisplay){
		if (colored != null) {
			for (Colorfull colorfull : colored) {
				if (colorfull != null && isInsideDisplay(colorfull.getColorCorners(),colorfull.getColorPosition(), 1, 1)) {
					gDisplay.setColor(colorfull.getColor());
					for (int i = 0; i < colorfull.getColorPolygon().npoints; i++) {
						colorfull.getColorPolygon().xpoints[i] = (colorfull.getColorPolygon().xpoints[i] + colorfull.getColorPosition().x)*colorfull.getColorPolygonScallingX();
						colorfull.getColorPolygon().ypoints[i] = (colorfull.getColorPolygon().ypoints[i] + colorfull.getColorPosition().y)*colorfull.getColorPolygonScallingX();						
					}
					gDisplay.fillPolygon(colorfull.getColorPolygon());
					for (int i = 0; i < colorfull.getColorPolygon().npoints; i++) {
						colorfull.getColorPolygon().xpoints[i] = colorfull.getColorPolygon().xpoints[i]/colorfull.getColorPolygonScallingX() - colorfull.getColorPosition().x;
						colorfull.getColorPolygon().ypoints[i] = colorfull.getColorPolygon().ypoints[i]/colorfull.getColorPolygonScallingY() - colorfull.getColorPosition().y;	
					}
				}
			}
		}		
	}
	
	public void render(){
		this.repaint();
	}
	/*
>>>>>>> refs/remotes/origin/Jesper
	public boolean render(Graphics2D gDisplay, Displayable d, RenderInfo renderInfo) {
		//Checks if the displayable has the neccesary information required for displaying it on the screen.
		if (d == null) {
			throw new NullPointerException();
		}
		BufferedImage currentImage = d.getDisplayImage();
		Point2D.Double imagePosition = d.getDisplayPosition();
		if (currentImage == null || imagePosition == null) {
			throw new NullPointerException();
		} else {
			//Checks if the displayable is in a position, so that the image can be displayed on the screen. 
			//If not, it dosen't render it (to increase performance), else it does.
			if (isInsideDisplay(d.getCorners(), d.getDisplayPosition(), currentImage.getWidth(), currentImage.getHeight())) {
				if (!renderInfo.renderColor) {
<<<<<<< HEAD
<<<<<<< HEAD
=======
					Rectangle destRect = new Rectangle((int) ((imagePosition.x + renderInfo.xOffset) * tileSize * imageScaling), 
							  						   (int) ((imagePosition.y + renderInfo.yOffset) * tileSize * imageScaling), 
							  						   (int) (tileSize * imageScaling), 
							  						   (int) (tileSize * imageScaling));
					
					Rectangle srcRect = new Rectangle((int) ((getPosition(d.getNumber() - 1, renderInfo.getSize()).x + renderInfo.xOffset) * (currentImage.getWidth() / renderInfo.getSize())), 
							  						  (int) ((getPosition(d.getNumber() - 1, renderInfo.getSize()).y + renderInfo.yOffset) * (currentImage.getHeight() / renderInfo.getSize())), 
							  						  (int) (currentImage.getWidth() / renderInfo.getSize()),
							  						  (int) (currentImage.getHeight() / renderInfo.getSize()));
>>>>>>> refs/remotes/origin/Andreas-2-
					gDisplay.drawImage(currentImage, 
									   destRect.x,
									   destRect.y,
									   destRect.x + destRect.width,
									   destRect.y + destRect.height,
									   srcRect.x,
									   srcRect.y,
									   srcRect.x + srcRect.width,
									   srcRect.y + srcRect.height,
									   null);
					} else {
					gDisplay.setColor(d.getColor());
<<<<<<< HEAD
<<<<<<< HEAD
					gDisplay.fillRect((int) ((imagePosition.x + renderInfo.xOffset) * currentImage.getWidth() * imageScaling), (int) ((imagePosition.y + renderInfo.yOffset) * currentImage.getHeight() * imageScaling), (int) (currentImage.getWidth() * imageScaling), (int) (currentImage.getHeight() * imageScaling));
					//gDisplay.fillRect((int) (imagePosition.x * imageScaling * currentImage.getWidth()), (int) (imagePosition.y * imageScaling * currentImage.getHeight()), currentImage.getWidth(), currentImage.getHeight());
=======
					gDisplay.fillRect((int) (imagePosition.x * imageScaling * currentImage.getWidth()), 
									  (int) (imagePosition.y * imageScaling * currentImage.getHeight()), 
									  currentImage.getWidth(), 
									  currentImage.getHeight());
>>>>>>> refs/remotes/origin/Andreas
				}
				gDisplay.setColor(Color.WHITE);
				gDisplay.drawString(String.valueOf(d.getNumber()), 
									(int) (((imagePosition.x + renderInfo.xOffset) * currentImage.getWidth() + currentImage.getWidth() / 2) * imageScaling), 
									(int) (((imagePosition.y + renderInfo.yOffset) * currentImage.getHeight() + currentImage.getHeight() / 2) * imageScaling));
=======
					gDisplay.drawImage(currentImage, (int) ((imagePosition.x + renderInfo.xOffset) * currentImage.getWidth() * renderInfo.imageScale), (int) ((imagePosition.y + renderInfo.yOffset) * currentImage.getHeight() * renderInfo.imageScale), (int) (currentImage.getWidth() * renderInfo.imageScale), (int) (currentImage.getHeight() * renderInfo.imageScale), null);
					//gDisplay.drawImage(currentImage, (int) ((imagePosition.x + renderInfo.xOffset) * renderInfo.imageScale * currentImage.getWidth()), (int) ((imagePosition.y + renderInfo.yOffset) * renderInfo.imageScale * currentImage.getHeight()), null);
				} else {
					gDisplay.setColor(d.getColor());
					gDisplay.fillRect((int) (imagePosition.x * renderInfo.imageScale * currentImage.getWidth()), (int) (imagePosition.y * renderInfo.imageScale * currentImage.getHeight()), currentImage.getWidth(), currentImage.getHeight());
				}
				gDisplay.setColor(Color.WHITE);
				gDisplay.drawString(String.valueOf(d.getNumber()), (int) (((imagePosition.x + renderInfo.xOffset) * currentImage.getWidth() + currentImage.getWidth() / 2) * renderInfo.imageScale), (int) (((imagePosition.y + renderInfo.yOffset) * currentImage.getHeight() + currentImage.getHeight() / 2) * renderInfo.imageScale));
>>>>>>> refs/remotes/origin/Emil
=======
					gDisplay.fillRect((int) (imagePosition.x * imageScaling * tileSize), 
									  (int) (imagePosition.y * imageScaling * tileSize), 
									  tileSize, 
									  tileSize);
				}
				gDisplay.setColor(Color.WHITE);
				gDisplay.drawString(String.valueOf(d.getNumber()), 
									(int) (((imagePosition.x + renderInfo.xOffset) * tileSize + tileSize / 2) * imageScaling), 
									(int) (((imagePosition.y + renderInfo.yOffset) * tileSize + tileSize / 2) * imageScaling));
>>>>>>> refs/remotes/origin/Andreas-2-
				return true;
			} else {
				return false;
			}
		}
	}
	
<<<<<<< HEAD
=======
	public Point2D.Double getPosition(int number, int size) {
		int row = number / size;
		int col = number % size;

		return new Point2D.Double(col, row);
	}
	

>>>>>>> refs/remotes/origin/Andreas-2-
	/**
	 * Tager ikke højde for tilfælde med rigtigt stort billed
	 * @param currentImage
	 * @param imagePosition
	 * @return
	 */
	/*
	public boolean isInsideDisplay(Displayable d) { //Rename? (*)
		//(*) Lave det om til polygoner?
		//Checks if any of the points along the image bounds of image to be displayed is inside the bounds of the display,
		//with the vantage point representing the middle of the display.
		BufferedImage dImage = d.getDisplayImage();
<<<<<<< HEAD
		Point2D.Double imagePosition = d.getDisplayPosition();
=======
		Point imagePosition =  d.getDisplayPosition();
>>>>>>> refs/remotes/origin/Jesper
		Point[] corners = d.getCorners();
		for (Point corner : corners) {
<<<<<<< HEAD
			if ((corner.x + imagePosition.x + renderInfo.xOffset) * dImage.getWidth() * renderInfo.imageScale < getWidth() &&
				(corner.y + imagePosition.y + renderInfo.yOffset) * dImage.getHeight() * renderInfo.imageScale < getHeight() && 
				(corner.x + imagePosition.x + renderInfo.xOffset) * dImage.getWidth() * renderInfo.imageScale > 0 &&
				(corner.y + imagePosition.y + renderInfo.yOffset) * dImage.getHeight() * renderInfo.imageScale > 0) {
=======
			if ((corner.x + imagePosition.x + renderInfo.xOffset) * tileSize < getWidth() &&
				(corner.y + imagePosition.y + renderInfo.yOffset) * tileSize < getHeight() && 
				(corner.x + imagePosition.x + renderInfo.xOffset) * tileSize > 0 &&
				(corner.y + imagePosition.y + renderInfo.yOffset) * tileSize > 0) {
>>>>>>> refs/remotes/origin/Andreas-2-
				return true;
			}
			
			/*if ((corner.x + imagePosition.x + renderInfo.xOffset) * dImage.getWidth() * imageScaling <= this.getWidth()
			&& (corner.y + imagePosition.y) * dImage.getHeight() * imageScaling <= this.getHeight()) {
				return true;
			}*/
			/*if ((corner.x + imagePosition.x + renderInfo.xOffset) * dImage.getWidth() * imageScaling <= this.getWidth() && 
			(corner.y + imagePosition.y + renderInfo.yOffset) * dImage.getHeight() * imageScaling <= this.getHeight() &&
			(corner.x + imagePosition.x + renderInfo.xOffset) * dImage.getWidth() * imageScaling  >= renderInfo.xOffset * dImage.getWidth() * imageScaling &&
			(corner.y + imagePosition.y + renderInfo.yOffset) * dImage.getHeight() * imageScaling >= renderInfo.yOffset * dImage.getHeight() * imageScaling) {
			return true;
			}*/
		}
		return false;
	}
	*/
	
	public boolean isInsideDisplay(Point[] corners, Point startingPosition, int scallingX, int scallingY){
		if (corners != null) {
			for (Point corner : corners) {
				if ((corner.x + startingPosition.x) * scallingX * imageScaling <= this.getWidth() &&
						(corner.y + startingPosition.y) * scallingY * imageScaling <= this.getHeight()) {
						return true;
				}
			}
		} else {
			System.out.println();
		}	
		return false;		
	}
}
