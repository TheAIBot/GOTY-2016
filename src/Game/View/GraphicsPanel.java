package Game.View;

import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Rectangle;
import java.awt.geom.Point2D;
import java.awt.image.BufferedImage;
import javax.swing.JPanel;

import Game.Control.GameEngine.GraphicsManager;

public class GraphicsPanel extends JPanel {
	private static final long serialVersionUID = 1L; //autogenerated
	private Displayable[] tiles;
	private static final int DEFAULT_TILE_SIZE = 100;
	private final RenderInfo renderInfo;
	private final GraphicsManager gManager;
	private final int screenIndex;


	public GraphicsPanel(GraphicsManager gManager, RenderInfo renderInfo, int screenIndex) {
		super();
		this.gManager = gManager;
		this.setBackground(Color.WHITE);
		this.screenIndex = screenIndex;
		this.renderInfo = renderInfo;
	}

	//public void setRenderInfo(Displayable[] tiles, RenderInfo renderInfo) {
	//	this.tiles = tiles;
	//	this.renderInfo = renderInfo;
	//}

	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);		
		renderDisplayables(gManager.getDisplayablesToRender(screenIndex), g);
		renderColorfull(gManager.getColorfullsToRender(screenIndex), g);
		renderNumreable(gManager.getNumreablesToRender(screenIndex), g);
	}
	
	private void renderDisplayables(Displayable[] displayables, Graphics gDisplay){
		if (displayables != null) {
			for (Displayable d : displayables) {
				//Checks if the displayable has the neccesary information required for displaying it on the screen.
				if (d == null) {
					continue;
				}
				BufferedImage currentImage = d.getDisplayImage();
				Point2D.Double imagePosition = d.getDisplayPosition();
				if (currentImage == null || imagePosition == null) {
					throw new NullPointerException();
				} else {
					//Checks if the displayable is in a position, so that the image can be displayed on the screen. 
					//If not, it dosen't render it (to increase performance), else it does.
					if (isInsideDisplay(d.getCorners(), d.getDisplayPosition(), tileSize, tileSize)) {
						
						Rectangle destRect = new Rectangle((int) ((imagePosition.x + renderInfo.xOffset) * DEFAULT_TILE_SIZE * renderInfo.imageScale), 
		  						   						   (int) ((imagePosition.y + renderInfo.yOffset) * DEFAULT_TILE_SIZE * renderInfo.imageScale), 
		  						   						   (int) (DEFAULT_TILE_SIZE * renderInfo.imageScale), 
		  						   						   (int) (DEFAULT_TILE_SIZE * renderInfo.imageScale));						
						Rectangle srcRect = new Rectangle((int) ((getPosition(d.getNumber() - 1, renderInfo.getSize()).x) * (currentImage.getWidth() / renderInfo.getSize())), 
		  						  						  (int) ((getPosition(d.getNumber() - 1, renderInfo.getSize()).y ) * (currentImage.getHeight() / renderInfo.getSize())), 
		  						  						  (int) (currentImage.getWidth() / renderInfo.getSize()),
		  						  						  (int) (currentImage.getHeight() / renderInfo.getSize()));
						gDisplay.drawImage(currentImage, 
									   destRect.x, 
									   destRect.y,
									   destRect.x + destRect.width, 
									   destRect.y + destRect.height,
									   srcRect.x, 
									   srcRect.y,
									   srcRect.x + srcRect.width, 
									   srcRect.y + srcRect.height,
									   null);
									
					}
				}
			}
		}
	}
	
	private void renderNumreable(Numreable[] numreables, Graphics gDisplay){
		if (numreables != null) {
			for (Numreable numreable : numreables) {
				if (numreable != null) {
					Point2D.Double[] point = new Point2D.Double[]{numreable.getNumberPosition()};
					if (isInsideDisplay(point, new Point2D.Double(0, 0), 
							tileSize, tileSize)) {
						gDisplay.setColor(Color.WHITE);
						gDisplay.setFont(new Font("Verdana", 0, (int) (15 * renderInfo.imageScale)));
						gDisplay.drawString(String.valueOf(numreable.getNumber()), 
								(int) (((numreable.getNumberPosition().x + renderInfo.xOffset) * DEFAULT_TILE_SIZE + (DEFAULT_TILE_SIZE / 2)) * renderInfo.imageScale),
								(int) (((numreable.getNumberPosition().y + renderInfo.yOffset) * DEFAULT_TILE_SIZE + (DEFAULT_TILE_SIZE / 2)) * renderInfo.imageScale));
					}
				}
			}
		}		
	}
	
	private void renderColorfull(Colorfull[] colored, Graphics gDisplay){
		if (colored != null) {
			for (Colorfull colorfull : colored) {
				if (colorfull != null && isInsideDisplay(colorfull.getColorCorners(),colorfull.getColorPosition(), DEFAULT_TILE_SIZE, DEFAULT_TILE_SIZE)) {	
					gDisplay.setColor(colorfull.getColor());
					int[] xPoints = new int[colorfull.getColorPolygon().npoints];
					int[] yPoints = new int[colorfull.getColorPolygon().npoints];
					for (int i = 0; i < colorfull.getColorPolygon().npoints; i++) { //Kan vÃ¦rer en fejl her, med skiftet frem og tilbage imellem int og double (*)
						
						xPoints[i] = (int) Math.round((colorfull.getColorPolygon().xpoints[i] + colorfull.getColorPosition().x + renderInfo.xOffset) * DEFAULT_TILE_SIZE * renderInfo.imageScale);
						yPoints[i] = (int) Math.round((colorfull.getColorPolygon().ypoints[i] + colorfull.getColorPosition().y + renderInfo.yOffset) * DEFAULT_TILE_SIZE * renderInfo.imageScale);						
					}
					gDisplay.fillPolygon(xPoints, yPoints, colorfull.getColorPolygon().npoints);
					//gDisplay.fillPolygon(colorfull.getColorPolygon());
				}
			}
		}		
	}
	
	public void render(){
		this.repaint();
	}
	
	
	public boolean isInsideDisplay(Point2D.Double[] corners, Point2D.Double startingPosition, double scallingX, double scallingY){
		if (corners != null) {
			for (Point2D.Double corner : corners) { //Mulighed for fejl ved store eller drejede billeder(*)
				if (corner != null &&
					renderInfo != null &&
					(corner.x + startingPosition.x + renderInfo.xOffset) * scallingX * renderInfo.imageScale < getWidth() &&
					(corner.y + startingPosition.y + renderInfo.yOffset) * scallingY * renderInfo.imageScale < getHeight() &&
					(corner.x + startingPosition.x + renderInfo.xOffset) * scallingX * renderInfo.imageScale >= 0 &&
					(corner.y + startingPosition.y + renderInfo.yOffset) * scallingY * renderInfo.imageScale >= 0) {
					return true;
				}
			}
		}
		return false;		
	}
	
	
	public Point2D.Double getPosition(int number, int size) {
		int row = number / size;
		int col = number % size;
		return new Point2D.Double(col, row);
	}
}
