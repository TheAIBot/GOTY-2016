package Game.View;

import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Rectangle;
import java.awt.geom.Point2D;
import java.awt.image.BufferedImage;

import javax.swing.JPanel;

import Game.Control.GameEngine.GraphicsManager;

public class GraphicsPanel extends JPanel {
	private static final long serialVersionUID = 1L; //autogenerated
	private static final int DEFAULT_TILE_SIZE = 100; // the size of a tile in pixels
	private final RenderInfo renderInfo;
	private final GraphicsManager gManager;
	private final int screenIndex;
	private boolean firstPaint = true;

	public GraphicsPanel(GraphicsManager gManager, RenderInfo renderInfo, int screenIndex) {
		super();
		this.gManager = gManager;
		this.setBackground(Color.WHITE);
		this.screenIndex = screenIndex;
		this.renderInfo = renderInfo;
	}

	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		if (firstPaint) {
			setImageScale();
		}
		renderDisplayables(gManager.getDisplayablesToRender(screenIndex), g);
		renderColorfull(gManager.getColorfullsToRender(screenIndex), g);
		renderNumreable(gManager.getNumreablesToRender(screenIndex), g);
	}
	
	private void setImageScale()
	{
		double widthAndHeight = renderInfo.imageScale * DEFAULT_TILE_SIZE * renderInfo.getSize();
		double scaler = widthAndHeight / getHeight();
		double newImageScale = renderInfo.imageScale / scaler;
		renderInfo.setImageScale(newImageScale);
		firstPaint = false;
	}
	
	/**
	 * Render images
	 * @param displayables
	 * @param gDisplay
	 */
	private void renderDisplayables(Displayable[] displayables, Graphics gDisplay){
		if (displayables != null) {
			for (Displayable d : displayables) {
				//Checks if the displayable has the neccesary information required for displaying it on the screen.
				if (d == null) {
					continue;
				}
				BufferedImage currentImage = d.getDisplayImage();
				Point2D.Double imagePosition = d.getDisplayPosition();
				if (currentImage == null || imagePosition == null) {
					throw new NullPointerException();
				} else {
					//Checks if the displayable is in a position, so that the image can be displayed on the screen. 
					//If not, it dosen't render it (to increase performance), else it does.
					if (isInsideDisplay(d.getCorners(), d.getDisplayPosition(), DEFAULT_TILE_SIZE, DEFAULT_TILE_SIZE)) {
						
						//Move and scale the displayable to the corresponding position on the screen
						Rectangle destRect = new Rectangle((int) Math.ceil((imagePosition.x + renderInfo.xOffset) * DEFAULT_TILE_SIZE * renderInfo.imageScale), 
		  						   						   (int) Math.ceil((imagePosition.y + renderInfo.yOffset) * DEFAULT_TILE_SIZE * renderInfo.imageScale), 
		  						   						   (int) Math.ceil(DEFAULT_TILE_SIZE * renderInfo.imageScale), 
		  						   						   (int) Math.ceil(DEFAULT_TILE_SIZE * renderInfo.imageScale));						
						//Get the corresponding part of the source image to draw
						Rectangle srcRect = new Rectangle((int) Math.ceil((getPosition(d.getNumber() - 1, renderInfo.getSize()).x) * (currentImage.getWidth() / renderInfo.getSize())), 
		  						  						  (int) Math.ceil((getPosition(d.getNumber() - 1, renderInfo.getSize()).y ) * (currentImage.getHeight() / renderInfo.getSize())), 
		  						  						  (int) Math.ceil(currentImage.getWidth() / renderInfo.getSize()),
		  						  						  (int) Math.ceil(currentImage.getHeight() / renderInfo.getSize()));
						gDisplay.drawImage(currentImage, 
									   	   destRect.x, 
									   	   destRect.y,
									   	   destRect.x + destRect.width, 
									   	   destRect.y + destRect.height,
									   	   srcRect.x, 
									   	   srcRect.y,
									   	   srcRect.x + srcRect.width, 
									   	   srcRect.y + srcRect.height,
									   	   null);
									
					}
				}
			}
		}
	}
	
	private void renderNumreable(Numreable[] numreables, Graphics gDisplay){
		if (numreables != null && renderInfo.renderColor) {
			for (Numreable numreable : numreables) {
				if (numreable != null) {
					//Only Point2D.Double arrays can be used as parameter in the isInsedDisplay method
					Point2D.Double[] point = new Point2D.Double[]{numreable.getNumberPosition()};
					if (isInsideDisplay(point, new Point2D.Double(0, 0), 
							DEFAULT_TILE_SIZE, DEFAULT_TILE_SIZE)) {
						gDisplay.setColor(Color.WHITE);
						gDisplay.setFont(new Font("Verdana", 0, (int) (20 * renderInfo.imageScale)));
						//Finally draw the string contained in the numreable from the center of the tile
						gDisplay.drawString(String.valueOf(numreable.getNumber()), 
								(int) Math.ceil(((numreable.getNumberPosition().x + renderInfo.xOffset) * DEFAULT_TILE_SIZE + (DEFAULT_TILE_SIZE / 2)) * renderInfo.imageScale),
								(int) Math.ceil(((numreable.getNumberPosition().y + renderInfo.yOffset) * DEFAULT_TILE_SIZE + (DEFAULT_TILE_SIZE / 2)) * renderInfo.imageScale));
					}
				}
			}
		}		
	}
	
	private void renderColorfull(Colorfull[] colored, Graphics gDisplay){
		if (colored != null) {
			for (Colorfull colorfull : colored) {
				if (colorfull != null && isInsideDisplay(colorfull.getColorCorners(),colorfull.getColorPosition(), DEFAULT_TILE_SIZE, DEFAULT_TILE_SIZE)) {	
					gDisplay.setColor(colorfull.getColor());
					int[] xPoints = new int[colorfull.getColorPolygon().npoints];
					int[] yPoints = new int[colorfull.getColorPolygon().npoints];
					for (int i = 0; i < colorfull.getColorPolygon().npoints; i++) { 
						
						xPoints[i] = (int) Math.ceil((colorfull.getColorPolygon().xpoints[i] + colorfull.getColorPosition().x + renderInfo.xOffset) * DEFAULT_TILE_SIZE * renderInfo.imageScale);
						yPoints[i] = (int) Math.ceil((colorfull.getColorPolygon().ypoints[i] + colorfull.getColorPosition().y + renderInfo.yOffset) * DEFAULT_TILE_SIZE * renderInfo.imageScale);						
					}
					gDisplay.fillPolygon(xPoints, yPoints, colorfull.getColorPolygon().npoints);
				}
			}
		}		
	}
		
	public boolean isInsideDisplay(Point2D.Double[] corners, Point2D.Double startingPosition, double scallingX, double scallingY){
		if (corners != null) {
			for (Point2D.Double corner : corners) { 
				//Check after scaling and offset positioning, if the final position is contained in the window.
				if (corner != null &&
					renderInfo != null &&
					(corner.x + startingPosition.x + renderInfo.xOffset) * scallingX * renderInfo.imageScale < getWidth() &&
					(corner.y + startingPosition.y + renderInfo.yOffset) * scallingY * renderInfo.imageScale < getHeight() &&
					(corner.x + startingPosition.x + renderInfo.xOffset) * scallingX * renderInfo.imageScale >= 0 &&
					(corner.y + startingPosition.y + renderInfo.yOffset) * scallingY * renderInfo.imageScale >= 0) {
					return true;
				}
			}
		}
		return false;
	}
	
	public void render()
	{
		repaint();
	}
	
	/**
	 * 
	 * @param number
	 * @param size
	 * @return the corresponding position in the grid
	 */
	public Point2D.Double getPosition(int number, int size) {
		int row = number / size;
		int col = number % size;
		return new Point2D.Double(col, row);
	}
}
